= Consent

Consent is an access control abstraction layer for ActionController. It lets you restrict access
to actions across your application using a single rules file, rather than scattering access
logic across your controllers using verify() and method-specific logic. It acts as a single
before_filter to all your controllers and checks whether an action can run according to the
rules you've set.


== Examples

On installation, Consent adds a file to your app at config/consent.rb. This file is where you
write the access control rules for your application. You should see a block beginning:

  Consent.rules do

You should write all your rules inside this block. Each rule is made up of two parts: a
request expression, and a block that should return +true+ if the request is allowed, and
+false+ if it should be denied. For example, here's a simple rule that restricts requests
to <tt>SiteController#hello</tt> to only use Ajax:

  site.hello { request.xhr? }


=== Decision blocks

We'll deal with blocks first because they're simpler. They always appear at the end of a
rule, and should return +true+ if the request is allowed and +false+ if it should be denied.
Within the block, you have access to the +request+, +params+ and +session+ objects so you
can use them to make decisions about whether to allow the request (see the example above).


=== Helper methods

To make it easier to write clean rules and reduce repetition, Consent allows you to define
helper methods in the rule block that you can then use within rules to make decisions. For
example, let's say we want a method to grab the current user from the session:

  helper(:user) { User.find(session[:user_id]) }

We can then use this helper in our rules:

  profiles.update { user && user.is_admin? }


=== Request expressions

The first part of any rule is called the expression list. This is a snippet of Ruby
code that is used to match requests to the controllers in your application. The expression
language allows for matching of controllers, actions, parameters and HTTP methods, and
provides a declarative method for referring to your app's actions.

The basic grammar for expression lists is:

  list          ::=   expression [+ expression]*
  expression    ::=   controller[action]?[params]?
  controller    ::=   name[/name]*
  action        ::=   .name
  params        ::=   (:name => value[, :name => value]*)
  name          ::=   [a-z][a-z_]*
  value         ::=   integer|string|regexp|range

That might seem a little abstract, so here are some examples. In the right-hand column,
a symbol refers to a parameter, e.g. ":id" should be read as "params[:id]".

  Expression                          Requests matched
  ---------------------------------------------------------------------------------------
  site.hello                          SiteController#hello
  users                               All UsersController actions
  profiles.edit(:id => 12)            ProfilesController#edit where :id == 12
  pages(:id => "foo")                 All PagesController actions where :id == "foo"
  site(:name => /foo/i, :id => 4)     SiteController, :name contains "foo", :id == 4
  ajax/maps                           All actions in Ajax::MapsController
  ajax/maps.find                      Ajax::MapsController#find
  admin/users.search(:q => 4..8)      Admin::UsersController#search, :q between 4 and 8

Expressions are combined into a list using the <tt>+</tt> operator. For example, the
following complete rule matches <tt>SiteController#hello</tt> and all <tt>PagesController</tt>
actions where <tt>:id</tt> == <tt>"foo"</tt>, and restricts them so that they can only be
accessed using GET requests and a <tt>:name</tt> parameter:

  site.hello + pages(:id => "foo") { request.get? and !params[:name].nil? }


== Copyright

Copyright (c) 2009 James Coglan, released under the MIT license
