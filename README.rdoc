= Consent

Consent is an access control abstraction layer for ActionController. It lets you restrict access
to actions across your application using a single config file, rather than scattering access
logic across your controllers using verify() and method-specific logic. It acts as a single
before_filter to all your controllers and checks whether an action can run according to the
rules you've set. Think of it as a firewall that sits between your routes file and your
controller logic.


== Examples

On installation, Consent adds a file to your app at config/consent.rb. This file is where you
write the access control rules for your application. You should see a block beginning:

  Consent.rules do

You should write all your rules inside this block. Each rule is made up of two parts: a
request expression, and a block that should return +true+ if the request is allowed, and
+false+ if it should be denied. For example, here's a simple rule that restricts requests
to <tt>SiteController#hello</tt> to only use Ajax:

  site.hello { request.xhr? }


=== Request expressions

The first part of any rule is called the expression list. This is a snippet of Ruby
code that is used to match requests to the controllers in your application. The expression
language allows for matching of controllers, actions, parameters and HTTP methods, and
provides a declarative method for referring to your app's actions.

The basic grammar for expression lists is:

  list          ::=   expression [+ expression]*
  expression    ::=   controller[action]?[params]?
  controller    ::=   name[/name]*
  action        ::=   .name
  params        ::=   (:name => value[, :name => value]*)
  name          ::=   [a-z][a-z_]*
  value         ::=   integer|string|regexp|range

That might seem a little abstract, so here are some examples. In the right-hand column,
a symbol refers to a parameter, e.g. ":id" should be read as "params[:id]".

  Expression                          Requests matched
  ---------------------------------------------------------------------------------------
  site.hello                          SiteController#hello
  users                               All UsersController actions
  profiles.edit(:id => 12)            ProfilesController#edit where :id == 12
  pages(:id => "foo")                 All PagesController actions where :id == "foo"
  site(:name => /foo/i, :id => 4)     SiteController, :name contains "foo", :id == 4
  ajax/maps                           All actions in Ajax::MapsController
  ajax/maps.find                      Ajax::MapsController#find
  admin/users.search(:q => 4..8)      Admin::UsersController#search, :q between 4 and 8

Expressions are combined into a list using the <tt>+</tt> operator. For example, the
following complete rule matches <tt>SiteController#hello</tt> and all <tt>PagesController</tt>
actions where <tt>:id</tt> == <tt>"foo"</tt>, and restricts them so that they can only be
accessed using GET requests and a <tt>:name</tt> parameter:

  site.hello + pages(:id => "foo") { request.get? and !params[:name].nil? }


=== HTTP method filtering

You can also use HTTP verbs (get, post, etc) in your expressions to match more specific
requests. Each HTTP method takes a list of one or more expressions and narrows the scope
of the expressions to a specific verb. For example, this matches all <tt>UsersController</tt>
actions using any verb, POST requests to <tt>ProfilesController#update</tt>, and PUT
requests to <tt>TagsController</tt> and <tt>SiteController#hello</tt>:

  users + post(profiles.update) + put(tags + site.hello)


=== Decision blocks

Decision blocks always appear at the end of a rule, and should return +true+ if the request
is allowed and +false+ if it should be denied. Within the block, you have access to the
+request+, +params+ and +session+ objects so you can use them to make decisions about whether
to allow the request.

Within a decision block, you can use the words +deny+ and +allow+ to clean code up a bit.
Both these keywords cause the block to return early without processing any other instructions;
+deny+ denies the request and +allow+, well, allows it. For example, the following rule
blocks requests for <tt>:id</tt> between 45 and 60, except for if <tt>:id</tt> is 54:

  users.update(:id => 45..60) do
    allow if params[:id].to_i == 54
    false
  end

If <tt>:id</tt> is 54, the rule allows the request; +allow+ makes the block return early
so it does not return the value +false+ from its last expression.

You can also perform redirects from rule blocks using the +redirect+ keyword. Again, this
keyword blocks execution of the rest of the block, and it allows you to use the same
shorthand for action expressions as is used for matching requests (see above). For example,
here's a simple rule to block all requests to <tt>ProfilesController</tt>, redirecting
to <tt>SiteController#hello</tt>:

  profiles { redirect site.hello }

Note that if you only specify a controller with no action to redirect to, the Rails
convention is to use the +index+ action. For example, this rule redirects to
<tt>UsersController#index</tt> if there is no user logged in, otherwise the request
is allowed:

  profiles do
    redirect users unless session[:user]
    allow
  end


=== Helper methods

To make it easier to write clean rules and reduce repetition, Consent allows you to define
helper methods in the rule block that you can then use within rules to make decisions. For
example, let's say we want a method to grab the current user from the session:

  helper(:user) { User.find(session[:user_id]) }

We can then use this helper in our rules:

  profiles.update { user && user.is_admin? }


== Copyright

Copyright (c) 2009 James Coglan, released under the MIT license
